# 23种设计模式

## Iterator Pattern（迭代器模式）
> 多个元素的集合中将各个元素逐一取出来
 
## Adapter Pattern （适配器模式）
> 用来链接具有不同接口（API）的类
 
## Template Method Pattern （模板模式）
> 在父类种定义处理框架，在子类中进行具体处理 

## Factory Method Pattern （工厂模式）
> 在父类种定义生成接口的处理框架，在子类中进行具体处理

## Singleton Pattern （单例模式）
> 只允许生成一个实例

## Prototype Pattern (原型模式)
> 原型实例指定创建对象的种类，并且通过拷贝原型对象创建新的对象

## Builder Pattern （创建者模式）
> 当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式。

## Abstract Factory Pattern （抽象工厂模式）
> 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类

## Bridge Pattern （桥接模式）
> 按照功能层次结构与实现层次结构把一个两种扩展(继承)混在一起的程序进行分离，并在它们
> 之间搭建桥梁

## Strategy Pattern（策略模式）
> 整体地替换算法

## Composite Pattern （组合模式）
> 让容器和内容具有一致性，从而构建递归结构

## Decorator Pattern （装饰器模式）
> 让装饰边框与被装饰物具有一致性，并可以任意叠加装饰边框

## Visitor Pattern （访问者模式）
> 访问数据机构的同时重复套用相同操作；访问数据机构并处理数据

## Chain of Responsibility Pattern （责任链模式）
> 为请求创建了一个接收者对象的链

## Facade Pattern （外观模式）
> 提供一个统一的接口，用来访问子系统中的一群接口；
> 定义一个高层接口，让子系统更容易使用

## Mediator Pattern （中介者模式）
> 减少对象之间混乱的通信，由中介者对它们进行统一的协调

## Observer Pattern （观察者模式）
> 当一个对象被修改时，会自动通知依赖它的对象

## Memento Pattern （备忘录模式）
> 备忘录模式会捕获一个对象的内部状态，并在该对象之外保存这个状态，
> 从而可以在以后将对象恢复到原先保存的状态

## State Pattern（状态模式）
> 允许一个对象在其内部状态改变时改变它的行为。

## Flyweight Pattern（享元模式）
> 允许使用对象共享来有效地支持大量细粒度对象

## Proxy Pattern（代理模式）
> 代理模式为其他对象提供一种代理以控制对这个对象的访问

## Command Pattern（命令模式）
> 用类来表示请求和命令

## Interpreter Pattern（解释器模式）
> 用类来表现语法规则
